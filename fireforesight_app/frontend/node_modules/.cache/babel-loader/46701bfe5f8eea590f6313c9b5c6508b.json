{"ast":null,"code":"/**\n * @license\n * Copyright 2018-2020 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Safari doesn't support the EventTarget class, so we use a shim.\nimport { EventTarget } from \"event-target-shim\";\nimport { ArrowTable } from \"./ArrowTable\";\n/** Data sent in the custom Streamlit render event. */\n\n/** Messages from Component -> Streamlit */\nvar ComponentMessageType;\n/**\n * Streamlit communication API.\n *\n * Components can send data to Streamlit via the functions defined here,\n * and receive data from Streamlit via the `events` property.\n */\n\n(function (ComponentMessageType) {\n  ComponentMessageType[\"COMPONENT_READY\"] = \"streamlit:componentReady\";\n  ComponentMessageType[\"SET_COMPONENT_VALUE\"] = \"streamlit:setComponentValue\";\n  ComponentMessageType[\"SET_FRAME_HEIGHT\"] = \"streamlit:setFrameHeight\";\n})(ComponentMessageType || (ComponentMessageType = {}));\n\nexport class Streamlit {}\nStreamlit.API_VERSION = 1;\nStreamlit.RENDER_EVENT = \"streamlit:render\";\nStreamlit.events = new EventTarget();\nStreamlit.registeredMessageListener = false;\nStreamlit.lastFrameHeight = void 0;\n\nStreamlit.setComponentReady = () => {\n  if (!Streamlit.registeredMessageListener) {\n    // Register for message events if we haven't already\n    window.addEventListener(\"message\", Streamlit.onMessageEvent);\n    Streamlit.registeredMessageListener = true;\n  }\n\n  Streamlit.sendBackMsg(ComponentMessageType.COMPONENT_READY, {\n    apiVersion: Streamlit.API_VERSION\n  });\n};\n\nStreamlit.setFrameHeight = height => {\n  if (height === undefined) {\n    // `height` is optional. If undefined, it defaults to scrollHeight,\n    // which is the entire height of the element minus its border,\n    // scrollbar, and margin.\n    height = document.body.scrollHeight;\n  }\n\n  if (height === Streamlit.lastFrameHeight) {\n    // Don't bother updating if our height hasn't changed.\n    return;\n  }\n\n  Streamlit.lastFrameHeight = height;\n  Streamlit.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, {\n    height\n  });\n};\n\nStreamlit.setComponentValue = value => {\n  Streamlit.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, {\n    value\n  });\n};\n\nStreamlit.onMessageEvent = event => {\n  const type = event.data[\"type\"];\n\n  switch (type) {\n    case Streamlit.RENDER_EVENT:\n      Streamlit.onRenderMessage(event.data);\n      break;\n  }\n};\n\nStreamlit.onRenderMessage = data => {\n  let args = data[\"args\"];\n\n  if (args == null) {\n    console.error(`Got null args in onRenderMessage. This should never happen`);\n    args = {};\n  } // Parse our dataframe arguments with arrow, and merge them into our args dict\n\n\n  const dataframeArgs = data[\"dfs\"] && data[\"dfs\"].length > 0 ? Streamlit.argsDataframeToObject(data[\"dfs\"]) : {};\n  args = { ...args,\n    ...dataframeArgs\n  };\n  const disabled = Boolean(data[\"disabled\"]); // Dispatch a render event!\n\n  const eventData = {\n    disabled,\n    args\n  };\n  const event = new CustomEvent(Streamlit.RENDER_EVENT, {\n    detail: eventData\n  });\n  Streamlit.events.dispatchEvent(event);\n};\n\nStreamlit.argsDataframeToObject = argsDataframe => {\n  const argsDataframeArrow = argsDataframe.map(({\n    key,\n    value\n  }) => [key, Streamlit.toArrowTable(value)]);\n  return Object.fromEntries(argsDataframeArrow);\n};\n\nStreamlit.toArrowTable = df => {\n  const {\n    data,\n    index,\n    columns\n  } = df.data;\n  return new ArrowTable(data, index, columns);\n};\n\nStreamlit.sendBackMsg = (type, data) => {\n  window.parent.postMessage({\n    isStreamlitMessage: true,\n    type: type,\n    ...data\n  }, \"*\");\n};","map":{"version":3,"sources":["D:/Study/insight/project/fire_risk_prediction_SF/fireforesight_app/frontend/src/streamlit/streamlit.ts"],"names":["EventTarget","ArrowTable","ComponentMessageType","Streamlit","API_VERSION","RENDER_EVENT","events","registeredMessageListener","lastFrameHeight","setComponentReady","window","addEventListener","onMessageEvent","sendBackMsg","COMPONENT_READY","apiVersion","setFrameHeight","height","undefined","document","body","scrollHeight","SET_FRAME_HEIGHT","setComponentValue","value","SET_COMPONENT_VALUE","event","type","data","onRenderMessage","args","console","error","dataframeArgs","length","argsDataframeToObject","disabled","Boolean","eventData","CustomEvent","detail","dispatchEvent","argsDataframe","argsDataframeArrow","map","key","toArrowTable","Object","fromEntries","df","index","columns","parent","postMessage","isStreamlitMessage"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018-2020 Streamlit Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Safari doesn't support the EventTarget class, so we use a shim.\nimport { EventTarget } from \"event-target-shim\"\nimport { ArrowDataframeProto, ArrowTable } from \"./ArrowTable\"\n\n/** Data sent in the custom Streamlit render event. */\nexport interface RenderData {\n  args: any\n  disabled: boolean\n}\n\n/** Messages from Component -> Streamlit */\nenum ComponentMessageType {\n  // A component sends this message when it's ready to receive messages\n  // from Streamlit. Streamlit won't send any messages until it gets this.\n  // Data: { apiVersion: number }\n  COMPONENT_READY = \"streamlit:componentReady\",\n\n  // The component has a new widget value. Send it back to Streamlit, which\n  // will then re-run the app.\n  // Data: { value: any }\n  SET_COMPONENT_VALUE = \"streamlit:setComponentValue\",\n\n  // The component has a new height for its iframe.\n  // Data: { height: number }\n  SET_FRAME_HEIGHT = \"streamlit:setFrameHeight\",\n}\n\n/**\n * Streamlit communication API.\n *\n * Components can send data to Streamlit via the functions defined here,\n * and receive data from Streamlit via the `events` property.\n */\nexport class Streamlit {\n  /**\n   * The Streamlit component API version we're targetting.\n   * There's currently only 1!\n   */\n  public static readonly API_VERSION = 1\n\n  public static readonly RENDER_EVENT = \"streamlit:render\"\n\n  /** Dispatches events received from Streamlit. */\n  public static readonly events = new EventTarget()\n\n  private static registeredMessageListener = false\n  private static lastFrameHeight?: number\n\n  /**\n   * Tell Streamlit that the component is ready to start receiving data.\n   * Streamlit will defer emitting RENDER events until it receives the\n   * COMPONENT_READY message.\n   */\n  public static setComponentReady = (): void => {\n    if (!Streamlit.registeredMessageListener) {\n      // Register for message events if we haven't already\n      window.addEventListener(\"message\", Streamlit.onMessageEvent)\n      Streamlit.registeredMessageListener = true\n    }\n\n    Streamlit.sendBackMsg(ComponentMessageType.COMPONENT_READY, {\n      apiVersion: Streamlit.API_VERSION,\n    })\n  }\n\n  /**\n   * Report the component's height to Streamlit.\n   * This should be called every time the component changes its DOM - that is,\n   * when it's first loaded, and any time it updates.\n   */\n  public static setFrameHeight = (height?: number): void => {\n    if (height === undefined) {\n      // `height` is optional. If undefined, it defaults to scrollHeight,\n      // which is the entire height of the element minus its border,\n      // scrollbar, and margin.\n      height = document.body.scrollHeight\n    }\n\n    if (height === Streamlit.lastFrameHeight) {\n      // Don't bother updating if our height hasn't changed.\n      return\n    }\n\n    Streamlit.lastFrameHeight = height\n    Streamlit.sendBackMsg(ComponentMessageType.SET_FRAME_HEIGHT, { height })\n  }\n\n  /**\n   * Set the component's value. This value will be returned to the Python\n   * script, and the script will be re-run.\n   *\n   * For example:\n   *\n   * JavaScript:\n   * Streamlit.setComponentValue(\"ahoy!\")\n   *\n   * Python:\n   * value = st.my_component(...)\n   * st.write(value) # -> \"ahoy!\"\n   *\n   * The value must be serializable into JSON.\n   */\n  public static setComponentValue = (value: any): void => {\n    Streamlit.sendBackMsg(ComponentMessageType.SET_COMPONENT_VALUE, { value })\n  }\n\n  /** Receive a ForwardMsg from the Streamlit app */\n  private static onMessageEvent = (event: MessageEvent): void => {\n    const type = event.data[\"type\"]\n    switch (type) {\n      case Streamlit.RENDER_EVENT:\n        Streamlit.onRenderMessage(event.data)\n        break\n    }\n  }\n\n  /**\n   * Handle an untyped Streamlit render event and redispatch it as a\n   * StreamlitRenderEvent.\n   */\n  private static onRenderMessage = (data: any): void => {\n    let args = data[\"args\"]\n    if (args == null) {\n      console.error(\n        `Got null args in onRenderMessage. This should never happen`\n      )\n      args = {}\n    }\n\n    // Parse our dataframe arguments with arrow, and merge them into our args dict\n    const dataframeArgs =\n      data[\"dfs\"] && data[\"dfs\"].length > 0\n        ? Streamlit.argsDataframeToObject(data[\"dfs\"])\n        : {}\n\n    args = {\n      ...args,\n      ...dataframeArgs,\n    }\n\n    const disabled = Boolean(data[\"disabled\"])\n\n    // Dispatch a render event!\n    const eventData = { disabled, args }\n    const event = new CustomEvent<RenderData>(Streamlit.RENDER_EVENT, {\n      detail: eventData,\n    })\n    Streamlit.events.dispatchEvent(event)\n  }\n\n  private static argsDataframeToObject = (\n    argsDataframe: ArgsDataframe[]\n  ): object => {\n    const argsDataframeArrow = argsDataframe.map(\n      ({ key, value }: ArgsDataframe) => [key, Streamlit.toArrowTable(value)]\n    )\n    return Object.fromEntries(argsDataframeArrow)\n  }\n\n  private static toArrowTable = (df: ArrowDataframeProto): ArrowTable => {\n    const { data, index, columns } = df.data\n    return new ArrowTable(data, index, columns)\n  }\n\n  /** Post a message to the Streamlit app. */\n  private static sendBackMsg = (type: string, data?: any): void => {\n    window.parent.postMessage(\n      {\n        isStreamlitMessage: true,\n        type: type,\n        ...data,\n      },\n      \"*\"\n    )\n  }\n}\n\ninterface ArgsDataframe {\n  key: string\n  value: ArrowDataframeProto\n}\n"]},"metadata":{},"sourceType":"module"}